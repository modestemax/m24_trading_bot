'use strict';
var expect = require('chai').expect;
var anno = require('pd-api-test-anno')();
var announcer = require('pd-api-announcer');
var q = require('q');
var _ = require('underscore');

var eReport = require('pd-test-report-error');
var recMaker = require('pd-redis-base-record');
var setUnique = require('../');
var User = recMaker('user');
var Friendship = recMaker('friendship');
setUnique(User);
User.setUniqueDef('email', ['email']).setUniqueDef('ssn', ['ssn']);
setUnique(Friendship, {
    invitation: ['inviter', 'invitee']
});

var UserUniqEmail = User.withUnique('email');
var UserUniqSsn = User.withUnique('ssn');
var FsUniqInvitation = Friendship.withUnique('invitation');

describe('Set-unique', function () {
    var newUserProfile = {
        email: 'jack@email.com',
        ssn: '999-99-9999'
    };

    var newFsProfile = {
        inviter: 'john@email.com',
        invitee: 'jane@email.com'
    };

    var createdUserSid;
    var createFsSid;

    var usersToDelete = [];
    var fsToDelete = [];

    before(function (done) {
        anno.init(function () {
            var promises = [];
            _.range(6).forEach(function (num) {
                promises.push(
                    User.create({
                        email: 'user' + num + '@email.com',
                        ssn: num + '-' + num
                    }, function (multis) {
                        console.log(multis);
                        return multis;
                    }).then(function (sid) {
                        usersToDelete.push(sid);
                    })
                );
                promises.push(
                    Friendship.create({
                        inviter: 'finder' + num + '@email.com',
                        invitee: 'receiver' + num + '@email.com'
                    }).then(function (sid) {
                        fsToDelete.push(sid);
                    })
                );
            });

            return q.allSettled(promises);
        }, done, 'Set-unique');
    });


    it('should not create records with invalid inputs', function (done) {
        anno.tcase(function () {
            var promises = [];
            promises.push(
                User.create().then(function () {
                    eReport('Missed empty email input');
                }).fail(function (err) {
                    expect(err.message).to.equal('Must-be-NonEmptyString:email:of:email');
                    console.log('Caught empty email..');
                    return User.create({
                        email: 'user@email.com'
                    });
                }).then(function () {
                    eReport('Missed empty ssn');
                }).fail(function (err) {
                    expect(err.message).to.equal('Must-be-NonEmptyString:ssn:of:ssn');
                    console.log('Caught empty ssn..');
                })
            );
            promises.push(
                Friendship.create().then(function () {
                    eReport('Missed empty friendship');
                }).fail(function (err) {
                    expect(err.message).to.equal('Must-be-NonEmptyString:inviter:of:invitation');
                    console.log('Caught empty inviter..');
                    return Friendship.create({
                        inviter: newFsProfile.inviter
                    });
                }).then(function () {
                    eReport('Missed empty invitee');
                }).fail(function (err) {
                    expect(err.message).to.equal('Must-be-NonEmptyString:invitee:of:invitation');
                    console.log('Caught empty invitee..');
                })
            );
            return q.allSettled(promises).then(function (results) {
                announcer.assertFulfilledPromises(results, 'creation processes');
            });
        }, done, 'creating with invalid-input');
    });

    it('should create records with unique fields', function (done) {
        anno.tcase(function () {
            var promises = [];
            promises.push(
                UserUniqEmail.checkAbsenceOf(newUserProfile.email).then(function () {
                    console.log('uniq absence check passed..');
                    return UserUniqSsn.checkAbsenceOf(newUserProfile.ssn);
                }).then(function () {
                    return User.create(newUserProfile, function (multis) {
                        expect(multis.length).to.equal(4);
                        return multis;
                    });
                }).then(function (sid) {
                    createdUserSid = sid;
                    expect(sid).to.be.a('number');
                    console.log('created user with sid:' + sid);
                    usersToDelete.push(sid);
                }).fail(function (err) {
                    eReport(err);
                })
            );
            promises.push(
                Friendship.checkUniqAbsenceOf('invitation',
                    Friendship.uniqNm.uniqIdOf('invitation', newFsProfile)).then(function () {
                        console.log('uniq absence check passed..');
                        return Friendship.create(newFsProfile, function (multis) {
                            console.log(multis);
                            expect(multis.length).to.equal(3);
                            return multis;
                        });
                    }).then(function (sid) {
                        createFsSid = sid;
                        expect(sid).to.be.a('number');
                        console.log('created friendship with sid:' + sid);
                        fsToDelete.push(sid);
                    }).fail(function (err) {
                        eReport(err);
                    })
            );
            return q.allSettled(promises);
        }, done, 'Creating');
    });

    it('should stop duplication of unique fields', function (done) {
        anno.tcase(function () {
            var promises = [];
            promises.push(
                User.create({
                    email: newUserProfile.email,
                    ssn: newUserProfile.ssn + '1'
                }).then(function () {
                    eReport('missed duplicate email..');
                }).fail(function (err) {
                    announcer.assertReqErrorFor(err, 'email', 'taken');
                    console.log('caught duplicate of email..');
                    return User.create({
                        email: '1' + newUserProfile.email,
                        ssn: newUserProfile.ssn
                    });
                }).then(function () {
                    eReport('missed duplicate ssn..');
                }).fail(function (err) {
                    announcer.assertReqErrorFor(err, 'ssn', 'taken');
                    console.log('caught duplicate of ssn..');
                }).fail(function (err) {
                    eReport(err);
                })
            );
            promises.push(
                Friendship.create(newFsProfile).then(function () {
                    eReport('missed duplicate friendship..');
                }).fail(function (err) {
                    announcer.assertReqErrorFor(err, 'invitation', 'taken');
                    console.log('caught duplicate of invitation..');
                })
            );

            return q.allSettled(promises).then(function (results) {
                announcer.assertFulfilledPromises(results, 'creation processes');
            });
        }, done, 'stop-duplication');
    });

    it('should not modify records by invalid input', function (done) {
        anno.tcase(function () {
            var promises = [];
            promises.push(
                User.modify({
                    'pd-sid': createdUserSid,
                    email: 'user1@email.com'
                }, function (multis) {
                    console.error('should not have been here..');
                    console.error(multis);
                    return multis;
                }).then(function () {
                    eReport('missed taken email..');
                }).fail(function (err) {
                    announcer.assertReqErrorFor(err, 'email', 'taken');
                    console.log('caught taken email..');
                })
            );
            promises.push(
                Friendship.modify({
                    'pd-sid': createFsSid,
                    inviter: 'finder1@email.com'
                }).fail(function (err) {
                    announcer.assertSysErrorFor(err, 'invitation', 'partial-unique-change');
                    console.log('caught partial unique item change..');
                    return FsUniqInvitation.checkAbsenceExceptSid(createFsSid + '', 'finder1@email.com,receiver1@email.com');
                }).fail(function (err) {
                    announcer.assertReqErrorFor(err, 'invitation', 'taken');
                    console.log('Caught taken invitation..');
                }).then(function () {
                    return Friendship.modify({
                        'pd-sid': createFsSid,
                        inviter: 'finder1@email.com',
                        invitee: 'receiver1@email.com'
                    });
                }).fail(function (err) {
                    announcer.assertReqErrorFor(err, 'invitation', 'taken');
                    console.log('Caught taken invitation..');
                })
            );
            return q.allSettled(promises).then(function (results) {
                announcer.assertFulfilledPromises(results, 'modifications');
            });
        }, done, 'invalidly-modifying-records');
    });

    it('should be able to modify unique fields', function (done) {
        anno.tcase(function () {
            var promises = [];
            promises.push(
                User.modify({
                    'pd-sid': createdUserSid,
                    email: '1' + newUserProfile.email,
                    ssn: '2' + newUserProfile.ssn
                }, function (multis) {
                    console.log('found ' + multis.length + ' multis..');
                    console.log(multis);
                    expect(multis.length).to.equal(5);
                    return multis;
                }).then(function () {
                    console.log('modification executed..');
                    return User.findBySid(createdUserSid, {
                        fields: ['email', 'ssn']
                    });
                }).then(function (rec) {
                    console.log(rec);
                    expect(rec[0]).to.equal('1' + newUserProfile.email);
                    expect(rec[1]).to.equal('2' + newUserProfile.ssn);
                    return User.modify({
                        'pd-sid': createdUserSid,
                        'email': '1' + newUserProfile.email,
                        'status': 'fine'
                    }, function (multis) {
                        console.log('found ' + multis.length + ' multis');
                        console.log(multis);
                        expect(multis.length).to.equal(1);
                        return multis;
                    });
                }).then(function () {
                    return User.modify({
                        'pd-sid': createdUserSid,
                        email: newUserProfile.email,
                        ssn: newUserProfile.ssn
                    });
                }).fail(function (err) {
                    eReport(err);
                })
            );
            return q.allSettled(promises).then(function (results) {
                announcer.assertFulfilledPromises(results, 'modifications');
            });
        }, done, 'modifying-records');
    });

    it('should find matched unique set items', function (done) {

        anno.tcase(function () {
            return UserUniqEmail.matchBy('user*').then(function (result) {
                console.log('results of matchBy:---------------');
                console.log('cursor:' + result.cursor);
                console.log('records:');
                console.log(result.records);
                console.log('-------------------------------');
                expect(result.records.length).to.equal(6);
                return UserUniqEmail.matchListBy({
                    withCreatedAt: true
                }, 'user*');
            }).then(function (result) {
                console.log('Results of matchListBy:-------------');
                console.log('cursor:' + result.cursor);
                result.records.forEach(function (rec) {
                    console.log(rec);
                });
                console.log('-------------------------------');
                expect(result.records.length).to.equal(6);
                return UserUniqSsn.matchBy('*99*');
            }).then(function (result) {
                console.log('cursor:' + result.cursor);
                console.log('records:');
                console.log(result.records);
                expect(result.records.length).to.equal(1);
            }).fail(function (err) {
                eReport(err);
            });
        }, done, 'match-by-unique');
    });

    it('should find record by unique id', function (done) {
        anno.tcase(function () {
            return UserUniqEmail.findBy(newUserProfile.email).then(function (user) {
                console.log('Got User:');
                console.log(user);
                expect(user.email).to.equal(newUserProfile.email);
                expect(user.ssn).to.equal(newUserProfile.ssn);
                return UserUniqEmail.sidOf(newUserProfile.email);
            }).then(function (sid) {
                expect(sid + '').to.equal(createdUserSid + '');
                console.log('Got sid of unique email..');
            }).fail(function (err) {
                eReport(err);
            });
        }, done, 'find-by-unique');
    });

    after(function () {
        var promises = [];
        usersToDelete.forEach(function (sid) {
            promises.push(
                User.remove(sid, function (multis) {
                    console.log(multis);
                    return multis;
                }).then(function () {
                    return User.clearSidCounter();
                }).fail(function (err) {
                    eReport(err);
                })
            );
        });
        fsToDelete.forEach(function (sid) {
            promises.push(
                Friendship.remove(sid, function (multis) {
                    console.log(multis);
                    return multis;
                }).then(function () {
                    return Friendship.clearSidCounter();
                }).fail(function (err) {
                    eReport(err);
                })
            );
        });
        q.allSettled(promises);
    });
});