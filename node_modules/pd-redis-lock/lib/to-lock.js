'use strict';
var q = require('q');
var announcer = require('pd-api-announcer');
var redisMaker = require('pd-node-redis');
var defaultRedis = redisMaker.via();


var assertFiniteLoop = function (count) {
    if (count > 10) {
        console.error('Possible infinite loop');
        throw  announcer.error.sys('lock', 'too many tries');
    }
};


module.exports = function (lockName, expiresInMs, inputRedis) {
    var redis = inputRedis || defaultRedis;
    var expireCount = expiresInMs || 15000;

    var showTimestamp = function () {
        return (new Date()).getTime() + expireCount;
    };

    var nabLock = function () {
        var ts = showTimestamp();
        return redis.exec('setnx', [lockName, ts]).then(function (reply) {
            if (reply !== 1) {
                throw announcer.error.sys('lock', 'taken');
            }
        });
    };

    var checkExpiration = function () {
        return redis.exec('get', lockName).then(function (timestamp) {
            if ((new Date()).getTime() < parseInt(timestamp)) {
                //locked and not expired
                //fail to acquire lock
                if ((process.env.NODE_ENV || '') === 'test') {
                    console.warn(lockName + ': at ' + (new Date()).toLocaleString());
                }
                throw announcer.error.sys('lock', 'locked', timestamp);
            }
        });
    };

    var nabTimedOutLock = function () {
        //NodeJS side deadlock prevention
        //The quicker one will renew the lock's expiration while acquiring lock and the later one will have to wait..
        return redis.exec('getset', [lockName, showTimestamp()]).then(function (timestamp) {
            if ((new Date()).getTime() < parseInt(timestamp)) {
                //locked and not expired
                //fail to acquire lock
                if ((process.env.NODE_ENV || '') === 'test') {
                    console.warn('Expired but still locked:' + lockName + ': at ' + (new Date()).toLocaleString());
                }
                throw announcer.error.sys('lock', 'locked', timestamp);
            }
        });
    };


    //Based on http://redis.io/commands/setnx
    return q.Promise(function (resolve, reject) {
        var lockProcess = function (count) {
            assertFiniteLoop(count);
            nabLock().then(function () {
                resolve();
            }).fail(function (err) {
                if (announcer.error(err).isSysFor('lock', 'taken')) {
                    return checkExpiration().then(function () {
                        return nabTimedOutLock();
                    }).then(function () {
                        return 1;
                    }).fail(function (err) {
                        if (announcer.error(err).isSysFor('lock', 'locked')) {
                            return q('locked').delay(1000);
                        }
                    }).then(function (flag) {
                        return flag === 'locked' ? lockProcess(count + 1) : resolve();
                    });
                }
            }).fail(function (err) {
                reject(err);
            });
        };
        lockProcess(0);
    });
};