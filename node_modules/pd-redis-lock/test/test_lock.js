'use strict';
var q = require('q');
var _ = require('underscore');
var expect = require('chai').expect;
var assert = require('chai').assert;
var announcer = require('pd-api-announcer');
var eReport = require('./report-error');
var lock = require('../');
var toLock = require('../lib/to-lock');
var toUnlock = require('../lib/to-unlock');
var anno = require('pd-api-test-anno')();

describe('Data:lock', function () {
    it('should lock a record in a race condition', function (done) {
        anno.tcase(function () {
            var lockName = 'theLock';
            var ts = (new Date()).getTime();
            var promises = [];
            promises.push(
                lock(lockName, function () {
                    console.log('first access started..');
                }).fail(function (err) {
                    eReport(err);
                })
            );
            promises.push(
                lock(lockName, function () {
                    expect((new Date()).getTime() - ts).to.be.above(1000);
                    console.log('second access locked and released after about 1s...');
                }).fail(function (err) {
                    eReport(err);
                })
            );
            return q.allSettled(promises);
        }, done, 'lock-race-condition');

    });

    it('should lock regain the lock after a lock has been expired to avoid deadlock', function (done) {
        this.timeout(15000);
        anno.tcase(function () {
            var lockName = 'test:lock';
            var expiration = 500;
            return toLock(lockName, expiration).then(function () {
                return q.delay(600);
            }).then(function () {
                return toLock(lockName, expiration);
            }).then(function () {
                console.log('Expired lock regained...');
                return q.delay(600);
            }).then(function () {
                var promises = [];
                var ts = (new Date()).getTime();
                promises.push(toLock(lockName, expiration).then(function () {
                    console.log('Faster expiration robber regained lock....');
                }));
                promises.push(toLock(lockName, expiration).then(function () {
                    expect((new Date()).getTime() - ts).to.be.above(expiration);
                    console.log('Slower expiration robber gained lock after another expiration... ');
                }));
                return q.allSettled(promises);
            }).fin(function () {
                return toUnlock(lockName);
            }).fail(function (err) {
                eReport(err);
            });
        }, done, 'regain-expired-lock');
    });
});