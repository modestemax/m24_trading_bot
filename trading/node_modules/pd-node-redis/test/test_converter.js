'use strict';
var q = require('q');
var _ = require('underscore');
var expect = require('chai').expect;
var redis = require('../');
var redisConverter = redis.converters;
var eReport = require('./report-error');
var announcer = require('pd-api-announcer');
var anno = require('pd-api-test-anno')();

describe('Redis:utils', function () {
    var zsetName = 'myzset';
    var setName = 'myset';
    var testZset = [];
    var testSet = [];
    var dataNums = _.range(30);
    dataNums.forEach(function (i) {
        testZset.push(i);
        testZset.push('my' + i);
        testSet.push('my' + i);
    });
    before(function (done) {
        anno.init(function () {
            return redis.exec('zadd', [zsetName].concat(testZset)).fin(function () {
                return redis.exec('sadd', [setName].concat(testSet));
            });
        }, done, 'Redis:utils');
    });

    it('should get correct array converted by z2a', function (done) {
        console.log('Starting z2a converting test......................');
        anno.tcase(function () {
            return redis.exec('zrange', [zsetName, 0, -1, 'WITHSCORES']).then(function (zset) {
                return redisConverter.z2aWithScore(zset);
            }).then(function (arr) {
                _.range(3).forEach(function (i) {
                    expect(arr[i][0]).to.equal('my' + i);
                    expect(arr[i][1]).to.equal(i + '');
                    console.log('Tested converted item by z2aWithScore for ' + arr[i][0]);
                });
                return redis.exec('zrange', [zsetName, 0, -1]);
            }).then(function (zset) {
                return redisConverter.z2aNoScore(zset);
            }).then(function (arr) {
                _.range(3).forEach(function (i) {
                    expect(arr[i]).to.equal('my' + i);
                    console.log('Tested converted item by z2aNoScore for ' + arr[i]);
                });
            }).fail(function (err) {
                eReport(err);
            });
        }, done, 'z2a-conversion');

    });

    it('should scan all zset or set', function (done) {
        anno.tcase(function () {
            var promises = [];
            promises.push(
                redis.zScanAll(zsetName).then(function (arr) {
                    expect(arr.length).to.equal(dataNums.length);
                    console.log('Got all ' + arr.length + ' items in zset...');
                    _.range(3).forEach(function (i) {
                        expect(arr[i][0]).to.equal('my' + i);
                        expect(arr[i][1]).to.equal(i + '');
                        console.log(arr[i]);
                        console.log('Scanned zset item for ' + arr[i]);
                    });
                })
            );
            promises.push(
                redis.scanMatch(setName, 'my2*', 'sscan').then(function (arr) {
                    expect(arr.length).to.equal(11);  //2 and 2*
                    _.range(5).forEach(function (i) {
                        console.log(arr[i]);
                    });
                    console.log('Got all ' + arr.length + ' my2* items in set...');
                })
            );
            return q.allSettled(promises).then(function (results) {
                console.log(results);
                announcer.assertFulfilledPromises(results, 'scan processes');
            });
        }, done, 'zScanAll|scanMatch');

    });

    it('should check existence of items in the zset', function (done) {
        anno.tcase(function () {
            return redis.zsetExists(zsetName, 'my0').then(function (reply) {
                expect(reply[1][0]).to.equal('my0');
                console.log('zset item found..');
                return redis.zsetExists(zsetName, 'my' + dataNums.length);
            }).fail(function (err) {
                announcer.assertSysErrorFor(err, 'zsetItem', 'gone');
                console.log('rejected non-existing zset item..');
            }).fail(function (err) {
                eReport(err);
            });
        }, done, 'zsetExists');
    });

    it('should get latest zset with zSetLatest()', function (done) {
        anno.tcase(function () {
            return redis.zsetLatest(zsetName, {
                latest: (new Date().getTime()),
                earliest: 0
            }).then(function (arr) {
                expect(arr.length).to.equal(dataNums.length);
                console.log('Got all ' + arr.length + ' elements');
                _.range(dataNums.length - 1, dataNums.length - 4, -1).forEach(function (num, i) {
                    expect(arr[i][0]).to.equal('my' + num);
                    expect(arr[i][1]).to.equal(num + '');
                    console.log('zset item for ' + arr[i]);
                });
                return redis.zsetLatest(zsetName, {
                    latest: (new Date().getTime()),
                    earliest: 0,
                    limit: [3, dataNums.length - 3]
                });
            }).then(function (arr) {
                expect(arr.length).to.equal(dataNums.length - 3);
            }).fail(function (err) {
                eReport(err);
            });
        }, done, 'zsetLatest');
    });

    after(function (done) {
        anno.fin(function () {
            return redis.exec('del', zsetName).fail(function (err) {
                eReport(err);
            }).fin(function () {
                return redis.exec('del', setName);
            });
        }, done, 'Redis:util');
    });
});
