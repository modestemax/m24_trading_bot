'use strict';
var humanize = require('humanize-plus');
var extBear = require('./lib/extends-bear');
var extChildAmount = require('./lib/extends-child-amount');
var extChildSidsOf = require('./lib/extends-child-sids-of');
var extChildrenOf = require('./lib/extends-children-of');
var extHasChild = require('./lib/extends-has-child');
var extRemove = require('./lib/extends-remove');
var extAdopt = require('./lib/extends-adopt');
var extAbandon = require('./lib/extends-abandon');
var childize = require('./lib/childize');
var methodNomen = require('./lib/nomenclt');

/**
 * Parentized model will have extra methods such as
 * if Parent is 'message', Child is 'reply', then
 * Parent will have
 * Parent.bearReply()
 * Parent.replyAmount()
 * Parent.replySidsOf
 * Parent.repliesOf
 * Parent.hasReply
 * and
 * Parent.Reply pointing to a 'reply' model
 *
 *
 * The Child and the relationship are always stored in the same server
 * @param {object} Parent
 * @param {object} Child
 */
module.exports = function (Parent, Child) {
    var wrappedFlag = 'isParentOf' + Child.modelName();
    if (!Parent.isRedisModel || !Child.isRedisModel || Parent[wrappedFlag]) {
        return;
    }
    extBear(Parent, Child);
    extChildAmount(Parent, Child);
    extChildSidsOf(Parent, Child);
    extChildrenOf(Parent, Child);
    extHasChild(Parent, Child);
    extRemove(Parent, Child);
    extAdopt(Parent, Child);
    extAbandon(Parent, Child);

    var capitalizedChildName = humanize.capitalize(Child.modelName());
    Parent[capitalizedChildName] = Child;
    childize(Child, Parent);
    Parent[Child.modelName() + 'Owner'] = function (parentSid) {
        var pSid = (parentSid + '').trim();
        var uti = {};
        var bearerName = methodNomen.bearerFor(Child);
        uti.bear = function (childProfile, multiGen) {
            return Parent[bearerName](pSid, childProfile, multiGen);
        };

        var adpotName = methodNomen.adopt(Child);
        uti.adopt = function (childSid) {
            return Parent[adpotName](pSid, childSid);
        };

        var abandonName = methodNomen.abandon(Child);
        uti.abandon = function (childSid) {
            return Parent[abandonName](pSid, childSid);
        };

        var counterName = methodNomen.counterFor(Child);
        uti.kidAmount = function () {
            return Parent[counterName](pSid);
        };

        var sidListName = methodNomen.sidListFor(Child);
        uti.findKidSids = function (option) {
            return Parent[sidListName](pSid, option);
        };

        var childListName = methodNomen.childListOf(Child);
        uti.findKids = function (option) {
            return Parent[childListName](pSid, option);
        };

        var ifOwnsName = methodNomen.ifOwns(Child);
        uti.hasKid = function (childSid) {
            return Parent[ifOwnsName](pSid, childSid);
        };
        return uti;
    };

    Parent[wrappedFlag] = true;
};
